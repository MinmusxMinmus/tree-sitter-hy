#+TITLE: tree-sitter-hy

Tree-sitter grammar for [[https://hylang.org/][Hy]].

Originally planned to be based on [[https://github.com/kwshi/tree-sitter-hy][kwshi/tree-sitter-hy]], but I decided to try my
hand from scratch.  I did have a look at [[https://github.com/kwshi/tree-sitter-hy/issues/1][this issue]], which noted a couple
improvements for kwshi's implementation, and I'll try to implement them.  This
grammar targets Hy version 1.0.0.

* Motivation

I mainly use Python at work, and Hy seemed to solve a couple of our issues so I
looked into using it more often.  The language itself is pretty easy, but I
didn't find many developer tools with all the features I wanted (I tried
[[https://github.com/sakuraiyuta/hyuga][sakuraiyuta/hyuga]] and [[https://github.com/hylang/hy-mode][hylang/hy-mode]], but I felt like they were a bit lacking).
I was incidentally also interested in messing around with tree-sitter for some
personal projects, and a Lisp seemed like a very good starting point to get a
grasp of the basics.  My eventual goal is to use this grammar as a building
block for further improvements to my Hy development environment (I plan on
making my own Hy language server, also for learning purposes).

* Features

In no particular order:

- Numeric literals (hexadecimal, octal, decimal, binary, floating point,
  complex).

- Exact literals (=NaN=, =Inf=, =...=, =True=, =False=, =None=).

- Shebang.

- Symbols and keywords.

- Dotted identifiers.

- Strings, raw strings and byte strings (and any combination).

- f-strings (with support for combination with raw strings/byte strings, and
  recursive strings of any type).

- Bracket strings (with support for arbitrary delimiters, bracket f-strings, and
  recursive strings of any type).

- Lists, sets, dictionaries, and S-expressions.

- Quoted, quasiquoted, unquoted, and unquote-spliced forms.

- Discard prefixes (with support for recursive discard prefixes, as well as
  presence of discard prefixes in strange spots such as between a quote and a
  form).

* Contributing

I'm not looking for anything in particular.  Since this is partly a learning
project I would like to implement most of it myself, but obviously any and all
contributions are welcome.

* Pending

In no particular order:

- Better bracket string error recovery.

- More field names.

- Comprehensive test suite.

- Full support for =#^=.

- Support for =#*=.

- Support for =#**=.

- Potentially adding better, more descriptive nodes for:

  - ~do~, ~do-mac~, ~eval-and-compile~, ~eval-when-compile~, ~py~, ~pys~, ~pragma~.

  - ~quote~, ~quasiquote~, ~unquote~, ~unquote-splice~.

  - ~setv~, ~setx~, ~global~, ~nonlocal~, ~del~, ~annotate~, ~deftype~.

  - ~.~, ~unpack-iterable~, ~unpack-mapping~.

  - ~if~, ~else~, ~when~, ~cond~, ~unless~, ~while~, ~break~, ~continue~.

  - ~for~, ~lfor~, ~dfor~, ~gfor~, ~sfor~.

  - ~with~, ~match~.

  - ~raise~, ~try~, ~except~, ~except*~, ~finally~.

  - ~defn~, ~fn~, ~return~, ~yield~, ~await~.

  - ~defmacro~, ~defreader~, ~get-macro~, ~local-macros~.

  - ~defclass~.

  - ~import~, ~require~, ~export~.

  - ~chainc~, ~assert~.

  The reason I'm not sure I want to do this is that all these macros are
  overridable by the user if they feel like it.  It's reasonable to make some
  assumptions about very common macros like ~import~, but for something like
  ~unless~ (which requires explicit importing) it could be too fragile, and
  overall it might be a better idea to let users of the parser choose what they
  give special treatment to.
